{"ast":null,"code":"export default function stifle(fn, wait) {\n  if (typeof fn !== 'function' || typeof wait !== 'number') {\n    throw new Error('stifle(fn, wait) -- expected a function and number of milliseconds, got (' + typeof fn + ', ' + typeof wait + ')');\n  }\n\n  var timer; // Timer to fire after `wait` has elapsed\n\n  var called; // Keep track if it gets called during the `wait`\n\n  var wrapper = function () {\n    // Check if still \"cooling down\" from a previous call\n    if (timer) {\n      called = true;\n    } else {\n      // Start a timer to fire after the `wait` is over\n      timer = setTimeout(afterWait, wait); // And call the wrapped function\n\n      fn();\n    }\n  }; // Add a cancel method, to kill any pending calls\n\n\n  wrapper.cancel = function () {\n    // Clear the called flag, or it would fire twice when called again later\n    called = false; // Turn off the timer, so it won't fire after the wait expires\n\n    if (timer) {\n      clearTimeout(timer);\n      timer = undefined;\n    }\n  };\n\n  function afterWait() {\n    // Empty out the timer\n    timer = undefined; // If it was called during the `wait`, fire it again\n\n    if (called) {\n      called = false;\n      wrapper();\n    }\n  }\n\n  return wrapper;\n}","map":{"version":3,"sources":["C:/Users/Trace/Project 3/AutoMaintenance/client/node_modules/stifle/index.esm.js"],"names":["stifle","fn","wait","Error","timer","called","wrapper","setTimeout","afterWait","cancel","clearTimeout","undefined"],"mappings":"AAAA,eAAe,SAASA,MAAT,CAAiBC,EAAjB,EAAqBC,IAArB,EAA2B;AACxC,MAAI,OAAOD,EAAP,KAAc,UAAd,IAA4B,OAAOC,IAAP,KAAgB,QAAhD,EAA0D;AACxD,UAAM,IAAIC,KAAJ,CAAU,8EAA8E,OAAOF,EAArF,GAA0F,IAA1F,GAAiG,OAAOC,IAAxG,GAA+G,GAAzH,CAAN;AACD;;AAED,MAAIE,KAAJ,CALwC,CAK1B;;AACd,MAAIC,MAAJ,CANwC,CAM1B;;AAEd,MAAIC,OAAO,GAAG,YAAY;AAExB;AACA,QAAIF,KAAJ,EAAW;AACTC,MAAAA,MAAM,GAAG,IAAT;AACD,KAFD,MAEO;AACL;AACAD,MAAAA,KAAK,GAAGG,UAAU,CAACC,SAAD,EAAYN,IAAZ,CAAlB,CAFK,CAGL;;AACAD,MAAAA,EAAE;AACH;AACF,GAXD,CARwC,CAqBxC;;;AACAK,EAAAA,OAAO,CAACG,MAAR,GAAiB,YAAY;AAC3B;AACAJ,IAAAA,MAAM,GAAG,KAAT,CAF2B,CAI3B;;AACA,QAAID,KAAJ,EAAW;AACTM,MAAAA,YAAY,CAACN,KAAD,CAAZ;AACAA,MAAAA,KAAK,GAAGO,SAAR;AACD;AACF,GATD;;AAWA,WAASH,SAAT,GAAqB;AACnB;AACAJ,IAAAA,KAAK,GAAGO,SAAR,CAFmB,CAInB;;AACA,QAAIN,MAAJ,EAAY;AACVA,MAAAA,MAAM,GAAG,KAAT;AACAC,MAAAA,OAAO;AACR;AACF;;AAED,SAAOA,OAAP;AACD","sourcesContent":["export default function stifle (fn, wait) {\n  if (typeof fn !== 'function' || typeof wait !== 'number') {\n    throw new Error('stifle(fn, wait) -- expected a function and number of milliseconds, got (' + typeof fn + ', ' + typeof wait + ')');\n  }\n\n  var timer;    // Timer to fire after `wait` has elapsed\n  var called;   // Keep track if it gets called during the `wait`\n\n  var wrapper = function () {\n\n    // Check if still \"cooling down\" from a previous call\n    if (timer) {\n      called = true;\n    } else {\n      // Start a timer to fire after the `wait` is over\n      timer = setTimeout(afterWait, wait);\n      // And call the wrapped function\n      fn();\n    }\n  }\n\n  // Add a cancel method, to kill any pending calls\n  wrapper.cancel = function () {\n    // Clear the called flag, or it would fire twice when called again later\n    called = false;\n\n    // Turn off the timer, so it won't fire after the wait expires\n    if (timer) {\n      clearTimeout(timer);\n      timer = undefined;\n    }\n  }\n\n  function afterWait() {\n    // Empty out the timer\n    timer = undefined;\n\n    // If it was called during the `wait`, fire it again\n    if (called) {\n      called = false;\n      wrapper();\n    }\n  }\n\n  return wrapper;\n}\n"]},"metadata":{},"sourceType":"module"}